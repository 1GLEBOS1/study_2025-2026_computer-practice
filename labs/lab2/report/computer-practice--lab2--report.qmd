---
## Author
author:
  name: Поляков Глеб Сергеевич
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 13

## Title
title: "Лабораторная работа №2"
subtitle: "Структуры данных"
license: "CC BY"
---

# Цель работы

Основная цель работы — изучить несколько структур данных, реализованных в Julia, научиться применять их и операции над ними для решения задач.

# Задание

1. Используя Jupyter Lab, повторите примеры из раздела 2.2.
2. Выполните задания для самостоятельной работы (раздел 2.4)

# Выполнение лабораторной работы


### 2.2.1. Кортежи

Кортеж (Tuple) — структура данных (контейнер) в виде неизменяемой индексируемой
последовательности элементов какого-либо типа (элементы индексируются с единицы).
Синтаксис определения кортежа:
(element1, element2, ...)
Примеры кортежей:
* пустой кортеж:
()
* кортеж из элементов типа String:
favoritelang = ("Python","Julia","R")
* кортеж из целых чисел:
x1 = (1, 2, 3)
* кортеж из элементов разных типов:
x2 = (1, 2.0, "tmp")
* именованный кортеж:
x3 = (a=2, b=1+2)
!["Примеры"](image/image_1.png){#fig-001 width=70%}
Примеры операций над кортежами:
* длина кортежа x2:
length(x2)
* обратиться к элементам кортежа x2:
x2[1], x2[2], x2[3]
* произвести какую-либо операцию (сложение) с вторым и третьим элементами кортежа x1:
с = x1[2] + x1[3]
* обращение к элементам именованного кортежа x3:
x3.a, x3.b, x3[2]
* проверка вхождения элементов tmp и 0 в кортеж x2
* (два способа обращения к методу in()):
in("tmp", x2), 0 in x2
!["Примеры"](image/image_2.png){#fig-002 width=70%}

### 2.2.2. Словари

Словарь — неупорядоченный набор связанных между собой по ключу данных.
Синтаксис определения словаря:
Dict(key1 => value1, key2 => value2, ...)
Примеры словарей и операций над ними:
* создать словарь с именем phonebook:
phonebook = Dict("Иванов И.И." => ("867-5309","333-5544"),
"Бухгалтерия" => "555-2368")↪

* вывести ключи словаря:
keys(phonebook)
* вывести значения элементов словаря:
values(phonebook)
*вывести заданные в словаре пары "ключ - значение":
pairs(phonebook)
* проверка вхождения ключа в словарь:
haskey(phonebook, "Иванов И.И.")
* добавить элемент в словарь:
phonebook["Сидоров П.С."] = "555-3344"
* удалить ключ и связанные с ним значения из словаря
pop!(phonebook, "Иванов И.И."):
!["Примеры"](image/image_3.png){#fig-003 width=70%}

* Объединение словарей (функция merge()):
a = Dict("foo" => 0.0, "bar" => 42.0);
b = Dict("baz" => 17, "bar" => 13.0);
merge(a, b), merge(b,a)
!["Примеры"](image/image_4.png){#fig-004 width=70%}

### 2.2.3. Множества

Множество, как структура данных в Julia, соответствует множеству, как математиче-
скому объекту, то есть является неупорядоченной совокупностью элементов какого-либо
типа. Возможные операции над множествами: объединение, пересечение, разность;
принадлежность элемента множеству.
Синтаксис определения множества:
Set([itr])
где itr — набор значений, сгенерированных данным итерируемым объектом или пустое
множество.
Примеры множеств и операций над ними:
* создать множество из четырёх целочисленных значений:
A = Set([1, 3, 4, 5])
* создать множество из 11 символьных значений:
B = Set("abrakadabra")
* проверка эквивалентности двух множеств:
S1 = Set([1,2]);
S2 = Set([3,4]);
issetequal(S1,S2)
S3 = Set([1,2,2,3,1,2,3,2,1]);
S4 = Set([2,3,1]);
issetequal(S3,S4)
!["Примеры"](image/image_5.png){#fig-005 width=70%}
* объединение множеств:
C=union(S1,S2)
* пересечение множеств:
D = intersect(S1,S3)
* разность множеств:
E = setdiff(S3,S1)
* проверка вхождения элементов одного множества в другое:
issubset(S1,S4)
* добавление элемента в множество:
push!(S4, 99)
* удаление последнего элемента множества:
pop!(S4)
!["Примеры"](image/image_6.png){#fig-006 width=70%}

### 2.2.4. Массивы

Массив — коллекция упорядоченных элементов, размещённая в многомерной сетке.
Векторы и матрицы являются частными случаями массивов.
Общий синтаксис одномерных массивов:
array_name_1 = [element1, element2, ...]
array_name_2 = [element1 element2 ...]
Примеры массивов:
* создание пустого массива с абстрактным типом:
empty_array_1 = []
* создание пустого массива с конкретным типом:
empty_array_2 = (Int64)[]
empty_array_3 = (Float64)[]
* вектор-столбец:
a = [1, 2, 3]
* вектор-строка:
b = [1 2 3]
* многомерные массивы (матрицы):
A = [[1, 2, 3] [4, 5, 6] [7, 8, 9]]
B = [[1 2 3]; [4 5 6]; [7 8 9]]
!["Примеры"](image/image_7.png){#fig-007 width=70%}

* одномерный массив из 8 элементов (массив $1 \times 8$)
* со значениями, случайно распределёнными на интервале [0, 1):
c = rand(1,8)
* многомерный массив $2 \times 3$ (2 строки, 3 столбца) элементов
* со значениями, случайно распределёнными на интервале [0, 1):
C = rand(2,3);
* трёхмерный массив:
D = rand(4, 3, 2)
Примеры массивов, заданных некоторыми функциями через включение:
* массив из квадратных корней всех целых чисел от 1 до 10:
roots = [sqrt(i) for i in 1:10]
!["Примеры"](image/image_8.png){#fig-008 width=70%}

* массив с элементами вида 3*x^2,
* где x - нечётное число от 1 до 9 (включительно)
ar_1 = [3*i^2 for i in 1:2:9]
* массив квадратов элементов, если квадрат не делится на 5 или 4:
ar_2=[i^2 for i=1:10 if (i^2%5!=0 && i^2%4!=0)]
Некоторые операции для работы с массивами:

- length(A) — число элементов массива A;
- ndims(A) — число размерностей массива A;
- size(A) — кортеж размерностей массива A;
- size(A, n) — размерность массива A в заданном направлении;
- copy(A) — создание копии массива A;
- ones(), zeros() — создать массив с единицами или нулями соответственно;
- fill(value,array_name) — заполнение массива заранее определенным значением;
- sort() — сортировка элементов;
- collect() — вернуть массив всех элементов в коллекции или итераторе;
- reshape() — изменение размера массива;
- transpose() — транспонирование массива;
Несколько примеров:
* одномерный массив из пяти единиц:
ones(5)
* двумерный массив 2x3 из единиц:
ones(2,3)
* одномерный массив из 4 нулей:
zeros(4)
* заполнить массив 3x2 цифрами 3.5
fill(3.5,(3,2))
!["Примеры"](image/image_9.png){#fig-009 width=70%}

* заполнение массива посредством функции repeat():
repeat([1,2],3,3)
repeat([1 2],3,3)
* преобразование одномерного массива из целых чисел от 1 до 12
* в двумерный массив 2x6
a = collect(1:12)
b = reshape(a,(2,6))
* транспонирование
b'
* транспонирование
с = transpose(b)
!["Примеры"](image/image_10.png){#fig-010 width=70%}

* массив 10x5 целых чисел в диапазоне [10, 20]:
ar = rand(10:20, 10, 5)
* выбор всех значений строки в столбце 2:
ar[:, 2]
* выбор всех значений в столбцах 2 и 5:
ar[:, [2, 5]]
!["Примеры"](image/image_11.png){#fig-011 width=70%}
* все значения строк в столбцах 2, 3 и 4:
ar[:, 2:4]
* значения в строках 2, 4, 6 и в столбцах 1 и 5:
ar[[2, 4, 6], [1, 5]]
* значения в строке 1 от столбца 3 до последнего столбца:
ar[1, 3:end]
* сортировка по столбцам:
sort(ar,dims=1)
!["Примеры"](image/image_12.png){#fig-012 width=70%}
* сортировка по строкам:
sort(ar,dims=2)
* поэлементное сравнение с числом
* (результат - массив логических значений):
ar .> 14
!["Примеры"](image/image_13.png){#fig-013 width=70%}
* возврат индексов элементов массива, удовлетворяющих условию:
findall(ar .> 14)
!["Примеры"](image/image_14.png){#fig-014 width=70%}

# Выводы

Изучил несколько структур данных, реализованных в Julia, научился применять их и операции над ними для решения задач

# Список литературы{.unnumbered}

::: {#refs}
:::
