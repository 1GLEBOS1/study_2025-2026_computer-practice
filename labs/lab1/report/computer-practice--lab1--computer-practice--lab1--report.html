<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Поляков Глеб Сергеевич">

<title>Отчёт по лабораторной работе №1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/clipboard/clipboard.min.js"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/popper.min.js"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/anchor.min.js"></script>
<link href="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="computer-practice--lab1--computer-practice--lab1--report_files/libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="computer-practice--lab1--computer-practice--lab1--report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="computer-practice--lab1--computer-practice--lab1--report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="computer-practice--lab1--computer-practice--lab1--report_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Отчёт по лабораторной работе №1</h1>
<p class="subtitle lead">Julia. Установка и настройка. Основные принципы.</p>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Поляков Глеб Сергеевич <a href="mailto:1132222845@rudn.ru" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Российский университет дружбы народов
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="цель-работы" class="level1">
<h1>Цель работы</h1>
<p>Основная цель работы — подготовить рабочее пространство и инструментарий для работы с языком программирования Julia, на простейших примерах познакомиться с основами синтаксиса Julia.</p>
</section>
<section id="задание" class="level1">
<h1>Задание</h1>
<ol type="1">
<li><p>Установите под свою операционную систему Julia, Jupyter (разделы 1.3.1 и 1.3.2).</p></li>
<li><p>Используя Jupyter Lab, повторите примеры из раздела 1.3.3.</p></li>
<li><p>Выполните задания для самостоятельной работы (раздел 1.3.4).</p></li>
</ol>
</section>
<section id="теоретическое-введение" class="level1">
<h1>Теоретическое введение</h1>
</section>
<section id="выполнение-лабораторной-работы" class="level1">
<h1>Выполнение лабораторной работы</h1>
<section id="подготовка-инструментария-к-работе" class="level2">
<h2 class="anchored" data-anchor-id="подготовка-инструментария-к-работе">1.3.1. Подготовка инструментария к работе</h2>
<p>Установите Julia (https://julialang.org/) и Jupyter (https://jupyter.org/) под вашу операционную систему. Для ОС типа Windows рекомендуется для установки использовать менеджер пакетов Chocolatey (https://chocolatey.org/), устанавливаемый через Administrative Shell. Далее рекомендуется посредством данного менеджера установить Far Manager, Notepad++, Julia, Anaconda Distribution (Python 3.x). После установки запустите Julia в режиме REPL (read-eval-print loop). Если вы работаете под ОС Linux, то в командной строке введите julia. После запуска Julia вы попадёте в режим командной строки. Установите пакеты для работы с Jupyter. Для этого перейдите в пакетный режим Julia, нажав на клавиатуре знак закрывающейся квадратной скобки ] , затем введите add IJulia.</p>
<p>В ОС Linux пакеты будут установлены в каталог ~/.local/share/jupyter/kernels в подкаталог с соответствующей версией ядра Julia. В случае изменения версии ядра Кулябов Д. С. и др. Компьютерный практикум на языке Julia 7 необходимо будет использовать пакеты под новое ядро, а каталог с предыдущим номером версии ядра нужно удалить. Для возвращения в основной командный режим Julia необходимо нажать BackSpace . Для выхода из командного интерфейса Julia используйте сочетание клавиш Ctrl + d . Для интерактивной работы с Julia удобно использовать или Jupyter Notebook, или Jupyter Lab. По своей сути блокнот Jupyter позволяет объединить в единый документ тест, программный код, результат его выполнения и визуализацию результата. Основная работа с блокнотами осуществляется посредством браузера. Формат документов (.ipynb) идентичен в Jupyter Notebook и Jupyter Lab. Для запуска Jupyter Notebook из-под ОС Linux в командной строке введите jupyter notebook. Если браузер автоматически не загрузит страницу с блокнотом Jupyter, то в строке браузера введите http://localhost:8888/tree. Для прекращения работы с Jupyter Notebook используйте сочетание клавиш Ctrl + c . Для запуска Jupyter Lab из-под ОС Linux в командной строке введите jupyter lab или в строке браузера http://localhost:8888/lab. Для прекращения работы с Jupyter Lab используйте сочетание клавиш Ctrl + c . В Windows запустить Jupyter Lab вы можете с помощью ярлыка, добавленного в меню «Пуск» после установки Anaconda.</p>
</section>
<section id="основы-работы-в-блокноте-jupyter" class="level2">
<h2 class="anchored" data-anchor-id="основы-работы-в-блокноте-jupyter">1.3.2. Основы работы в блокноте Jupyter</h2>
<p>Запустите Jupyter Lab. Каждый блокнот (или консоль, или терминал, или текстовый редактор) располагается в своей вкладке в основной рабочей области. Для создания нового блокнота выберите в меню File New , далее укажите, что именно вы хотите создать, например, Notebook , затем ядро Juliia-1.x . Для открытия существующего файла используйте стандартные пункты меню и навигатор. Каждый файл-блокнот представляет собой текстовый файл в формате JSON с описанием всего содержимого блокнота. Обычно файл имеет расширение .ipynb или .ipyn. Основная концепция интерактивных блокнотов — это ячейка, содержащая отдельный фрагмент текста (или кода). Для написания текста в ячейке нужно в панели инструментов указать Markdown, для написания элемента кода — Code. Для изменения режимов вставки ячеек можно использовать также комбинации клавиш. Для этого нужно на активной ячейке нажать ESC , что выведет ячейку из режима редактирования и переведёт её в командный режим, в котором есть специальные сочетания клавиш для вставки / вырезания / изменения ячеек:</p>
<ul>
<li>a или b — создать новую ячейку соответственно выше или ниже текущей;</li>
<li>x — удалить ячейку;</li>
<li>z — отмена удаления ячейки;</li>
<li>m — перевести ячейку в режим текста;</li>
<li>y — перевести ячейку в режим набора кода.</li>
</ul>
<p>Для выполнения кода внутри ячейки выберите эту ячейку и нажмите Shift + Enter или кнопку со значком Run на панели инструментов. Если ячейка содержит несколько строк кода, то при выполнении этой ячейки отобразится только результат последней строки (операции). Вывод результата можно подавить, завершив строку знаком «точка с запятой». Примеры по выполнению кода с простейшей операцией сложения в блокноте Jupyter приведены на рис. 1.2.</p>
<p>Если вам необходимо получить информацию по работе с какой-то незнакомой для вас функцией Julia, то вы можете поставить в ячейке перед названием этой функции знак вопроса (рис. 1.3). Рис. 1.3. Пример получения информации по функции println на языке Julia в Jupyter Lab Если требуется использовать команды из командной оболочки вашей операционной системы, то перед соответствующей командой нужно поставить знак «точка с запятой». Например, для пользователей ОС Linux можно вывести текущую дату и имя пользователя, используя последовательно команды date и whoami (рис. 1.3). Для пользователей других ОС следует использовать команды оболочки соответствующей операционной системы. Для очистки результатов выполнения ячеек следует использовать меню Edit Clear Outputs или Edit Clear All Outputs .</p>
</section>
<section id="основы-синтаксиса-julia-на-примерах" class="level2">
<h2 class="anchored" data-anchor-id="основы-синтаксиса-julia-на-примерах">1.3.3. Основы синтаксиса Julia на примерах</h2>
<p>С основами синтаксиса языка Julia можно ознакомиться в источниках [1—5]. Далее приведены простейшие примеры с использованием синтаксиса Julia, выполненные в блокноте Jupyter Lab. Определение типа числовой величины: typeof(Number) Здесь Number — конкретное число, например, 3 или 3.5, или числовой результат какой-либо операции, например, 3/3.5, √3 + 4𝑖, значение числа 𝜋. В Julia введены специальные значения Inf, -Inf, NaN, обозначающие бесконечность и отсутствие какого-либо значения. Такие значения могут получаться в результате операций типа деления на ноль, а также могут быть допустимой частью выражений, поскольку в языке имеют тип вещественного числа (см. рис. 1.5). Для определения крайних значений диапазонов целочисленных числовых величин можно воспользоваться следующим кодом:</p>
<pre><code>for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]↪
println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
end</code></pre>
<p>В результате получим минимальные и максимальные значения целочисленных типов (см. рис. 1.5). В Julia преобразование типов можно реализовать или прямым указанием, например вещественное число 2.0 преобразовать в целое, а число 2 в символ: Int64(2.0), Char(2) или использовать обобщённый оператор преобразования типов convert(), например: convert(Int64, 2.0), convert(Char,2) Преобразование 1 в булевое true, 0 — в булевое false: Bool(1), Bool(0) Для приведения нескольких аргументов к одному типу, если это возможно, используется оператор promote(), например: promote(Int8(1), Float16(4.5), Float32(4.1)) В данном выражении все аргументы оператора promote() в результате будут иметь тип Float32, в чём можно убедиться, воспользовавшись функцией определения типа typeof() (см. рис. 1.6). Базовый синтаксис определения функции: function &lt;Имя&gt; (&lt;СписокПараметров&gt;) &lt;Действия&gt; end Например, определим функцию 𝑓(𝑥) возведения переменной 𝑥 в квадрат и возведём в квадрат число 4 (см. рис. 1.7):</p>
<p>Другой способ определения несложных функций: &lt;Имя&gt; (&lt;СписокПараметров&gt;) = &lt;Выражение&gt; Например (см. рис. 1.7): g(x)=x^2</p>
<p>Пример определения одномерных массивов (вектор-строка и вектор-столбец) и обращение к их вторым элементам: a = [4 7 6] # вектор-строка b = [1, 2, 3] # вектор-столбец a[2], b[2] # вторые элементы векторов a и b Пример определения двумерного массива (матрицы) и обращение к его элементам: a = 1; b = 2; c = 3; d = 4 # присвоение значений Am = [a b; c d] # матрица 2 х 2 Am[1,1], Am[1,2], Am[2,1], Am[2,2] # элементы матрицы Пример выполнения операций над массивами (aa’ — транспонирование вектора(рис. 1.8)): aa = [1 2] AA = [1 2; 3 4] aa<em>AA</em>aa’</p>
</section>
<section id="задания-для-самостоятельной-работы" class="level2">
<h2 class="anchored" data-anchor-id="задания-для-самостоятельной-работы">1.3.4. Задания для самостоятельной работы</h2>
<ol type="1">
<li>Изучите документацию по основным функциям Julia для чтения / записи / вывода информации на экран: read(), readline(), readlines(), readdlm(), print(), println(), show(), write(). Приведите свои примеры их использования, поясняя особенности их применения.</li>
<li>Изучите документацию по функции parse(). Приведите свои примеры её использования, поясняя особенности её применения.</li>
<li>Изучите синтаксис Julia для базовых математических операций с разным типом переменных: сложение, вычитание, умножение, деление, возведение в степень, извлечение корня, сравнение, логические операции. Приведите свои примеры с пояснениями по особенностям их применения.</li>
<li>Приведите несколько своих примеров с пояснениями с операциями над матрицами и векторами: сложение, вычитание, скалярное произведение, транспонирование, умножение на скаляр.</li>
</ol>
<p>Описываются проведённые действия, в качестве иллюстрации даётся ссылка на иллюстрацию (<a href="#fig-001" class="quarto-xref">рис.&nbsp;1</a>).</p>
<div id="fig-001" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-001-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="image/solvay.jpg" class="img-fluid figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-001-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: V Сольвеевский конгресс (1927) «Электроны и фотоны»
</figcaption>
</figure>
</div>
</section>
</section>
<section id="выводы" class="level1">
<h1>Выводы</h1>
</section>
<section id="список-литературы" class="level1 unnumbered">
<h1 class="unnumbered">Список литературы</h1>
<div id="refs" role="list">

</div>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>